# Version control of Jupyter notebooks

Jupyter notebook generates files that contain  metadata, source code, formatted text and rich media. Only one word of change results in thousands of letter in `git diff`. This makes these files poor candidates for conventional version control solutions, which works best with plain text. <br>

Version control is an important creative tool that enables experimentation and eases collaboration between peers. It lowers the risks of making a mistake or erasing another person's work because a complete record exists of all changes. <br>

Exploration is a critical part of data analysis. Jupyter's inherent interactivity has made it a popular tool amongst data scientists and researchers. It has taken several years, but version control solutions are beginning to catch up. <br>

## Problems with Jupyter and Version Control

Jupyter notebook files are human-readable JSON `.ipynb` files. <br>
It is uncommon to edit the JSON source directly because the format is so verbose; it's easy to forget required punctuation, unbalance brackets like `{}` and`[]` and corrupt the file. More troublesome, Jupyter source code is often littered cell output stored as binary blobs.<br>


## Built-In Solutions

### Clear Output Manually

The simplest solution is to always clear the output before committing. <br>
`Cell -> All Output -> Clear -> Save`. <br>
This removes any binary blobs that have been generated by the notebook. <br>

#### but:

1. manual process <br>
2. collaborators on other machines will need to rerun the notebook to see the output (takes additional time)<br>
3. collaborators on other machines may still create noise when new metadata is generated<br>

### Convert to HTML

As a best practice, many Jupyter users will generate HTML and pure Python versions of their notebook using the built-in `nbconvert` tool. This ensures the output can easily be displayed by any computer with a web browser. <br>

### Convert to Python

`jupyter nbconvert --to="python"` creates a short and readable record of the notebook's code cells. <br>
The simple Python document is perfect for version control and makes working in teams much easier. Changes are easily spotted and diffs are more readable. <br>


## External Tools

### jupyterlab-git


[jupyterlab-git](https://github.com/jupyterlab/jupyterlab-git) is an extension for JupyterLab that integrates a UI for Git into JupyterLab. Notebooks can be changed, staged, pushed, pulled and merged direclty from within JupyterLab with a few mouseclicks. Unlike Git, jupyterlab-git has the option to convert binary blobs into graphs while inspecting changes, which makes diffing a lot cleaner and user friendly. <br>

<p align="center">
<img src="https://raw.githubusercontent.com/jupyterlab/jupyterlab-git/master/docs/figs/preview.gif" width="70%" height="70%"><br>
</p>

Hint: [Git integration](https://code.visualstudio.com/docs/sourcecontrol/overview) within VS Code is another possibility and similar to jupyterlab-git. VS Code will use the machine's Git installation. It is possible to customize what types of changes you want displayed within your [diffing view](https://code.visualstudio.com/docs/datascience/jupyter-notebooks#_custom-notebook-diffing). 

#### Installation

    pip install --upgrade jupyterlab jupyterlab-git
    conda install -c conda-forge jupyterlab jupyterlab-git

JupyterLab version >= 3.0, Git version >= 2.x and a Git credential manager are required.


### nbdime

[nbdime](https://github.com/jupyter/nbdime) is a tool that understands the structure of `.ipynb` files and is designed to diff and merge them. Similar to Git, nbdime is a command line tool. But unlike Git it does not show endless lines of binary blobs when some of the output changed, but highlights the change in context. nbdime also wants to offer visual, browser-based diffing and merging using `nbdiff-web` and `nbmerge-web` which still have some issues at the moment.<br>

nbdime merges two notebooks based on a common parent notebook and writes the output to stdout if not redirected into a file.

    nbdiff notebook_1.ipynb notebook_2.ipynb # show changes between two versions of a notebook
    nbdiff-web notebook_1.ipynb notebook_2.ipynb # opens a browser-based diffing interface

    nbmerge base.ipynb local.ipynb remote.ipynb > merged.ipynb # merge two notebooks
    nbmerge-web base.ipynb local.ipynb remote.ipynb --out merged.ipynb # opens webapp for manual merging
        # base: the base, common parent notebook
        # local: your local changes to base
        # remote: other changes to base that you want to merge with yours

Different options control the diffing and matching process and can be read in the [documentation](https://nbdime.readthedocs.io/en/latest/cli.html). <br>

Since Git does not handle `.ipynb` notebooks that well, it can be [configured](https://nbdime.readthedocs.io/en/latest/vcs.html) to use `nbdiff` and `nbmerge` as default diffing and merging tools.<br>


#### Installation

    pip install --upgrade nbdime


### jupytext

[jupytext](https://github.com/mwouts/jupytext) takes a different approach. Instead of trying to version control the notebook itself, jupytext creates a simple, git-friendly text file (`.py`, `.md`, `.r` and [others](https://github.com/mwouts/jupytext/blob/main/docs/config.md)) that is paired to the notebook. While the `.ipynb` file contains the whole notebook (input and output), the text file only contains the input and some metadata. Whenever the notebook is opened, input cells are loaded from the text file and the output is restored from the .`ipynb` file. When the notebook is saved, the input cells are synced to the text file. <br>

The text file can easily be version controlled. Two people can push, pull and merge the text files as they would with any other project and changes will always be loaded into their notebooks. The `.ipynb` file never needs to be shared, unless someone wants to share their output.

In this video the author of jupytext gives a short introduction to his tool: [Marc Wouts - Jupytext: Jupyter Notebooks as Markdown Documents](https://www.youtube.com/watch?v=SDYdeVfMh48).

In JupyterLab versions 3.0 and above jupytext is available as extension which allows to create paired text files by selecting the corresponding command in the command palette (<kbd>sommand/ctrl + shift + C</kbd>). Additionally, using JupyterLab has the advantage that notebooks and text files are automatically synced every time either of them is saved. <br>

If JupyterLab is not used, jupytext also offers [commands](https://github.com/mwouts/jupytext/blob/main/docs/using-cli.md) for the command line:

    jupytext --set-formats ipynb,py --sync notebook.ipynb # create a paired .py file for the .ipynb notebook
    jupytext --sync notebook.ipynb # synchronise the notebook and text files

Hint: if only the text file should be version controlled, Git can be configured to ignore diffs in `.ipynb` files: [Link](https://github.com/mwouts/jupytext/issues/251).


#### Installation

    pip install jupytext --upgrade
    conda install jupytext -c conda-forge
